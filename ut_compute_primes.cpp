// ut_compute_primes.cpp

#include <algorithm>
#include <iostream>
#include <sstream>

#include "compute_primes.h"

const int MAX_PRIME_NUMBER {1013};

// credits: https://primes.utm.edu/lists/small/10000.txt
const std::set<int> primes_1009
{
      2,      3,      5,      7,     11,     13,     17,     19,     23,     29,
     31,     37,     41,     43,     47,     53,     59,     61,     67,     71,
     73,     79,     83,     89,     97,    101,    103,    107,    109,    113,
    127,    131,    137,    139,    149,    151,    157,    163,    167,    173,
    179,    181,    191,    193,    197,    199,    211,    223,    227,    229,
    233,    239,    241,    251,    257,    263,    269,    271,    277,    281,
    283,    293,    307,    311,    313,    317,    331,    337,    347,    349,
    353,    359,    367,    373,    379,    383,    389,    397,    401,    409,
    419,    421,    431,    433,    439,    443,    449,    457,    461,    463,
    467,    479,    487,    491,    499,    503,    509,    521,    523,    541,
    547,    557,    563,    569,    571,    577,    587,    593,    599,    601,
    607,    613,    617,    619,    631,    641,    643,    647,    653,    659,
    661,    673,    677,    683,    691,    701,    709,    719,    727,    733,
    739,    743,    751,    757,    761,    769,    773,    787,    797,    809,
    811,    821,    823,    827,    829,    839,    853,    857,    859,    863,
    877,    881,    883,    887,    907,    911,    919,    929,    937,    941,
    947,    953,    967,    971,    977,    983,    991,    997,   1009
};

const std::set<int> primes_1013
{
      2,      3,      5,      7,     11,     13,     17,     19,     23,     29,
     31,     37,     41,     43,     47,     53,     59,     61,     67,     71,
     73,     79,     83,     89,     97,    101,    103,    107,    109,    113,
    127,    131,    137,    139,    149,    151,    157,    163,    167,    173,
    179,    181,    191,    193,    197,    199,    211,    223,    227,    229,
    233,    239,    241,    251,    257,    263,    269,    271,    277,    281,
    283,    293,    307,    311,    313,    317,    331,    337,    347,    349,
    353,    359,    367,    373,    379,    383,    389,    397,    401,    409,
    419,    421,    431,    433,    439,    443,    449,    457,    461,    463,
    467,    479,    487,    491,    499,    503,    509,    521,    523,    541,
    547,    557,    563,    569,    571,    577,    587,    593,    599,    601,
    607,    613,    617,    619,    631,    641,    643,    647,    653,    659,
    661,    673,    677,    683,    691,    701,    709,    719,    727,    733,
    739,    743,    751,    757,    761,    769,    773,    787,    797,    809,
    811,    821,    823,    827,    829,    839,    853,    857,    859,    863,
    877,    881,    883,    887,    907,    911,    919,    929,    937,    941,
    947,    953,    967,    971,    977,    983,    991,    997,   1009,   1013
};

const std::size_t ok_col_pos   { 58 };  // column position for "ok" text   See note1

// rtrim() -- toss trailing dots from end of a string
//
// credits: https://stackoverflow.com/a/217605
static inline void rtrim(std::string &s)
{
    s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch)
            {
                return ch != '.';
            }
        ).base(), s.end()
    );
}


// note1:   for readablity I favor formatting UT chatter
//          in text columns. Generally the first column is
//          a description of what the given UT is testing and
//          the second column shows that the test passed (e.g., "ok").
//
//          The text emitted when a UT fails is formatted differently
//          WRT chatter from a successful UT. Put another way,
//          a UT failure emits text that visually clashes with
//          the text generated by successful UTs.
//
//          The human eyes is a mismatch detector.  This formatting
//          scheme intends to make a stream of successful UTs
//          "blend together" and any UT failures to visually clash
//          with the chatter from sucessful UTs. The visual clash will
//          cause any UT failure to be instantly noticed.
//
//  note4:  As per note1, we are inserting the "ok" text in a
//          second 'column' on the line.  We're using insert() to
//          create a "tab stop" effect where the second 'column' is
//          located.
//
//          This column's location follows the chatter about what the
//          given UT is testing. This "tab stop" is located beyond the
//          end of the chatter about what a given UT is testing.
//
//          string.insert(pos, text) will throw out_of_range if
//          pos > string length.
//
//          Consequently, we are padding the end of the first column's
//          chatter with dots so as to prevent string.insert()
//          from throwing "out_of_range" when we insert "ok" at
//          the second column's "tab stop".
//
//          I am padding with dots instead of whitespace because
//          the row of dots guide the viewer's eyes from the
//          text to the corresponding "ok"|"FAILED!" indication.
//
//
//==================================================================
//

void print_table(const std::set<int> & table)
{
    int i = 0;
    const int col{8};
    std::stringstream ss{};

    for (auto & elem : table)
    {
        std::stringstream tmp{"      "};
        tmp << elem << ",";

        std::string tmp_str( tmp.str() );

        tmp_str.erase( tmp_str.begin(), tmp_str.end()-col );
        ss << tmp_str;

        // if we have 10 elements on the line
        if (i == 10)
        {
            ss << std::endl; // do a linefeed
            i = 0;           // reset element counter
        }
        else    // we haven't yet filled up the line
        {
            i++; // inc the count of elements on the line
        }
    }

    std::cout << ss.str() << std::endl;
}

// ut_verify_prime_numbers() general purpose UT boilerplate for
// verifying that the table of prime numbers returned by the
// functor is correct
//
// keeping it DRY
int ut_verify_prime_numbers(
                                const std::string& utid,        // ut17, ut18, etc.
                                const std::string& intent,      // what UT is attempting to verify
                                const std::set<int> & results,  // actual table of primes computed
                                const std::set<int> & expected  // expected table of primes computed
                            )
{
    int something_failed = 1;    // init to UT failure
    std::stringstream ut_intent {};

    ut_intent <<  intent;

    std::cout << utid << ": ";

    // if the code worked as expected
    if (results == expected)
    {
        something_failed = 0; // indicate UT passed
    }

    if (something_failed)
    {
        std::cout << "FAILED!" << std::endl;
        std::cout << ut_intent.str() << std::endl;
        std::cout << "expected: " << std::endl;
        print_table(expected);
        std::cout << "encountered: " << std::endl;
        print_table(results);
    }
    else
    {
        //  format "UT Passed" chatter. See note1

        ut_intent <<  "......................................................";   // note4
        std::string tmp { ut_intent.str()  };
        tmp.insert( ok_col_pos, "ok" );     // columnize "ok" text   See note1
        rtrim(tmp);                         // toss trailing dots
        std::cout << tmp << std::endl;
    }

    return something_failed;
}



//======================= Unit Tests Begin ======================================
//
// case where limit is a prime number
int ut00()
{
    //------------------------------------------------------------
    //
    // setup for unit test
    //
    std::string ut_intent {  "case where limit is a prime number" };
    compute_primes cpc{};


    //------------------------------------------------------------
    //
    // conduct unit test
    //
    std::set<int> ut_primes = cpc(MAX_PRIME_NUMBER);

    return  ut_verify_prime_numbers(
                                        std::string { __func__ }, // utid,
                                        ut_intent,                // what UT is attempting to verify
                                        ut_primes,                // computed prime numbers
                                        primes_1013               // expected prime numbers
                                   );
}

//
// case where limit is a prime number+1
int ut01()
{
    //------------------------------------------------------------
    //
    // setup for unit test
    //
    std::string ut_intent {  "boundry checking: case where limit is a prime number+1" };
    compute_primes cpc{};


    //------------------------------------------------------------
    //
    // conduct unit test
    //
    std::set<int> ut_primes = cpc(MAX_PRIME_NUMBER+1);

    return  ut_verify_prime_numbers(
                                        std::string { __func__ }, // utid,
                                        ut_intent,                // what UT is attempting to verify
                                        ut_primes,                // computed prime numbers
                                        primes_1013               // expected prime numbers
                                   );
}

//
// case where limit is a prime number-1
int ut02()
{
    //------------------------------------------------------------
    //
    // setup for unit test
    //
    std::string ut_intent {  "boundry checking: case where limit is a prime number-1" };
    compute_primes cpc{};


    //------------------------------------------------------------
    //
    // conduct unit test
    //
    std::set<int> ut_primes = cpc(MAX_PRIME_NUMBER-1);

    return  ut_verify_prime_numbers(
                                        std::string { __func__ }, // utid,
                                        ut_intent,                // what UT is attempting to verify
                                        ut_primes,                // computed prime numbers
                                        primes_1009               // expected prime numbers
                                   );
}
//-----------------------------------------------------

int main( int argc, char * argv[] )
{
    bool something_failed = false;

    try
    {
        //something_failed += deliberately_throw_exception();
        //
        something_failed += ut00();     // case where limit is a prime number
        something_failed += ut01();     // case where limit is a prime number+1
        something_failed += ut02();     // case where limit is a prime number-1
    }
    catch (std::exception& e)
    {
        std::cerr << std::endl << "UNEXPECTED exception thrown: " << e.what() << std::endl << std::endl; // sent to console
        std::cout << std::endl << "UNEXPECTED exception thrown: " << e.what() << std::endl << std::endl; // sent to bitfield_ut_output.txt
        something_failed = 1;
    }

    if ( something_failed )
    {
        // note3:   One of the desired affects of a UT failure to
        //          "break the build". In this way UT failures
        //          cannot be ignored.
        //
        //          make aborts processing a Makefile wherever one of the
        //          Makefile's recipes terminates with non-zero exit status.
        //
        //          Consequently, this app must terminate with a
        //          non-zero exit status when any unit if its tests fail
        //          so as to break the build on UT failure.
        //
        std::cerr << std::endl << "UNIT TEST FAILED!" << std::endl;  // sent to the console
        std::cout << std::endl << "UNIT TEST FAILED!" << std::endl;  // sent to bitfield_ut_output.txt
        exit(EXIT_FAILURE);   // note3
    }
    else
    {
        std::cout << std::endl << "UNIT TEST passed!" << std::endl;
    }

    return 0;
}



